// Generated by CoffeeScript 1.12.6

/*
  ColorFormatter:
  Used to transform a color into different color formats
  it also has the logic to display the color formatter dialog and some class methods to transform a MSColor
  to a color Dictionary that can be saved in a layer
 */
var AndroidJavaFormatter, AndroidXMLFormatter, CLRFormatter, ColorFormatter, ColorSetFormatter, FormatterBase, HexFormatter, RGBACSSFormatter, SASSFormatter, SketchMeasureFormatter, UIColorObjCFormatter, UIColorSwiftFormatter,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ColorFormatter = (function() {
  ColorFormatter.prototype.FORMATS = [];

  ColorFormatter.prototype.FORMATS_BY_ID = [];

  ColorFormatter.prototype.colorClassifier = new ColorClassifier();

  function ColorFormatter() {

    /*
    **************** FORMATS ****************
      HERE is when you have to do the implementation of the new format you want to add.
     */
    var format, i, len, ref;
    this.FORMATS.push(new HexFormatter());
    this.FORMATS.push(new RGBACSSFormatter());
    this.FORMATS.push(new SASSFormatter());
    this.FORMATS.push(new CLRFormatter());
    this.FORMATS.push(new ColorSetFormatter());
    this.FORMATS.push(new UIColorSwiftFormatter());
    this.FORMATS.push(new UIColorObjCFormatter());
    this.FORMATS.push(new AndroidJavaFormatter());
    this.FORMATS.push(new AndroidXMLFormatter());
    this.FORMATS.push(new SketchMeasureFormatter());
    ref = this.FORMATS;
    for (i = 0, len = ref.length; i < len; i++) {
      format = ref[i];
      this.FORMATS_BY_ID[format.id()] = format;
    }
  }


  /*
    Shows the dialog to export the color dictionaries you provide
    returns a response code to know which button the user clicked.
   */

  ColorFormatter.prototype.showDialogWithColorDictionaries = function(colorDictionaries) {
    var accessory, alert, allColorsString, copyButton, formatObj, names, panel, pasteboard, responseCode, savePanel, selection, types;
    names = this.FORMATS.map(function(enc) {
      return enc.name();
    });
    types = this.FORMATS.map(function(enc) {
      return enc.type();
    });
    accessory = NSPopUpButton.alloc().initWithFrame_pullsDown(NSMakeRect(0, 0, 400, 25), false);
    accessory.addItemsWithTitles(names);
    accessory.selectItemAtIndex(0);
    alert = NSAlert.alloc().init();
    alert.setMessageText("Export colors");
    alert.setInformativeText("Select the color format:");
    alert.addButtonWithTitle('Save to file...');
    copyButton = alert.addButtonWithTitle('Copy to clipboard');
    alert.addButtonWithTitle('Cancel');
    alert.setAccessoryView(accessory);
    accessory.setCOSJSTargetFunction((function(_this) {
      return function(sender) {
        var obj, selection;
        selection = accessory.indexOfSelectedItem();
        obj = _this.FORMATS[selection];
        return copyButton.setEnabled(obj.supportClipboard());
      };
    })(this));
    responseCode = alert.runModal();
    selection = accessory.indexOfSelectedItem();
    formatObj = this.FORMATS[selection];
    switch (responseCode) {
      case 1000:
        log("Saving...");
        switch (formatObj.type()) {
          case FormatterBase.EXPORT_TYPE_FILE:
            savePanel = NSSavePanel.savePanel();
            savePanel.setNameFieldStringValue(formatObj.format());
            savePanel.setAllowsOtherFileTypes(true);
            savePanel.setExtensionHidden(false);
            if (savePanel.runModal()) {
              formatObj.exportAsFile(colorDictionaries, savePanel.URL());
            }
            break;
          case FormatterBase.EXPORT_TYPE_FILES:
            panel = NSOpenPanel.openPanel();
            panel.prompt = "Export";
            panel.message = "Choose export directory";
            panel.canChooseFiles = false;
            panel.canChooseDirectories = true;
            panel.allowsMultipleSelection = false;
            panel.canCreateDirectories = true;
            if (panel.runModal()) {
              formatObj.exportAsFile(colorDictionaries, panel.URL());
            }
            break;
          default:
            log("Unknown type");
        }
        break;
      case 1001:
        log("Copying...");
        allColorsString = formatObj.exportAsString(colorDictionaries);
        pasteboard = NSPasteboard.generalPasteboard();
        pasteboard.declareTypes_owner([NSPasteboardTypeString], null);
        pasteboard.setString_forType(allColorsString, NSPasteboardTypeString);
    }
    return responseCode;
  };

  ColorFormatter.prototype.formatColorDictionary_withFormat_commented = function(colorDictionary, format, commented) {
    var formatter;
    formatter = this.FORMATS_BY_ID[format];
    return formatter.formatText(colorDictionary, commented);
  };


  /*
    Takes a MSColor and a name or alias and packs it on a dictionary representation that can be then saved on a layer using the PluginCommand
   */

  ColorFormatter.colorToDictionary = function(color, name) {
    var dictionary;
    return dictionary = {
      name: name,
      hex: color.immutableModelObject().hexValue(),
      red: color.red(),
      blue: color.blue(),
      green: color.green(),
      alpha: color.alpha()
    };
  };


  /*
    Takes a the dictionary representation from above and returns a new MSColor instance
   */

  ColorFormatter.dictionaryToColor = function(dictionary) {
    var color;
    return color = MSColor.colorWithRed_green_blue_alpha(dictionary.red, dictionary.green, dictionary.blue, dictionary.alpha);
  };

  return ColorFormatter;

})();


/*
**************** FORMATS ****************
  HERE is when you have to do the implementation of the new format you want to add.
 */


/*
 FormatterBase

 Base class for each type of formatters. Template Pattern.
 the ID must be unique, the name is a human readable mini description, the format is used to use a custom file extension when saving colors to a file
 */

FormatterBase = (function() {
  function FormatterBase() {}

  FormatterBase.EXPORT_TYPE_FILE = "file";

  FormatterBase.EXPORT_TYPE_FILES = "files";


  /*
   id
  
   Override this at Subclass.
   */

  FormatterBase.prototype.id = function() {};


  /*
   id
  
   Override this at Subclass.
   */

  FormatterBase.prototype.id = function() {};


  /*
   name
  
   Uses format name on modal panel. Override this at Subclass.
   */

  FormatterBase.prototype.name = function() {};


  /*
   format
  
   Uses default file name when its saved. Override this at Subclass.
   */

  FormatterBase.prototype.format = function() {};


  /*
   type
  
   `EXPORT_TYPE_FILE` or `EXPORT_TYPE_FILES`. Override this at Subclass.
   */

  FormatterBase.prototype.type = function() {
    return this.constructor.EXPORT_TYPE_FILE;
  };


  /*
   supportClipboard
  
   If format supports clipboard then returns `true`.
   */

  FormatterBase.prototype.supportClipboard = function() {
    return true;
  };


  /*
   formatText
  
   Converts a Color Dictionary to String. Override this at Subclass.
   The commented flag is used to add comments (like when we export colors)
   or removing them (like when we are populating the cell layers with color data)
   */

  FormatterBase.prototype.formatText = function(color, commented) {};


  /*
   formatTextFromColorDictionaries
  
   Converts Color Dictionaries to String. Override this at Subclass if needs.
   */

  FormatterBase.prototype.formatTextFromColorDictionaries = function(colorDictionaries) {
    var allColorsString, colorDictionary, i, len, lines;
    lines = [];
    for (i = 0, len = colorDictionaries.length; i < len; i++) {
      colorDictionary = colorDictionaries[i];
      lines.push(this.formatText(colorDictionary, true));
    }
    return allColorsString = lines.join("\n");
  };


  /*
   writeStringToFile
  
   Writes String type format as file. Override this at Subclass if needs.
   */

  FormatterBase.prototype.writeStringToFile = function(filePath, string) {
    var fileString;
    fileString = NSString.stringWithString(string);
    return fileString.writeToFile_atomically_encoding_error(filePath, true, NSUTF8StringEncoding, null);
  };


  /*
   exportAsFile
  
   Writes format as file. Override this at Subclass if needs.
   */

  FormatterBase.prototype.exportAsFile = function(colorDictionaries, url) {
    var text;
    text = this.exportAsString(colorDictionaries);
    return this.writeStringToFile(url.path(), text);
  };


  /*
   exportAsString
  
   Converts Color Dictionaries to String. Override this at Subclass if needs.
   */

  FormatterBase.prototype.exportAsString = function(colorDictionaries) {
    var text;
    return text = this.formatTextFromColorDictionaries(colorDictionaries);
  };

  return FormatterBase;

})();

HexFormatter = (function(superClass) {
  extend(HexFormatter, superClass);

  function HexFormatter() {
    return HexFormatter.__super__.constructor.apply(this, arguments);
  }

  HexFormatter.prototype.id = function() {
    return "HEX";
  };

  HexFormatter.prototype.name = function() {
    return "HEX CSS";
  };

  HexFormatter.prototype.format = function() {
    return "colors.css";
  };

  HexFormatter.prototype.formatText = function(color, commented) {
    var formattedColor;
    formattedColor = '#' + color.hex;
    if (commented) {
      return formattedColor + "; /* " + color.name + " */";
    } else {
      return formattedColor;
    }
  };

  return HexFormatter;

})(FormatterBase);

RGBACSSFormatter = (function(superClass) {
  extend(RGBACSSFormatter, superClass);

  function RGBACSSFormatter() {
    return RGBACSSFormatter.__super__.constructor.apply(this, arguments);
  }

  RGBACSSFormatter.prototype.id = function() {
    return "RGBA_CSS";
  };

  RGBACSSFormatter.prototype.name = function() {
    return "RGBA CSS";
  };

  RGBACSSFormatter.prototype.format = function() {
    return "colors.css";
  };

  RGBACSSFormatter.prototype.formatText = function(color, commented) {
    var alpha, formattedColor;
    alpha = color.alpha < 1 ? color.alpha.toFixed(2) : color.alpha;
    formattedColor = "rgba(" + (Math.round(color.red * 255)) + "," + (Math.round(color.green * 255)) + "," + (Math.round(color.blue * 255)) + "," + alpha + ");";
    if (commented) {
      return formattedColor + " /* " + color.name + " */";
    } else {
      return formattedColor;
    }
  };

  return RGBACSSFormatter;

})(FormatterBase);

SASSFormatter = (function(superClass) {
  extend(SASSFormatter, superClass);

  function SASSFormatter() {
    return SASSFormatter.__super__.constructor.apply(this, arguments);
  }

  SASSFormatter.prototype.id = function() {
    return "SASS";
  };

  SASSFormatter.prototype.name = function() {
    return "SASS variables";
  };

  SASSFormatter.prototype.format = function() {
    return "_colors.scss";
  };

  SASSFormatter.prototype.formatText = function(color, commented) {
    var formattedColor, sassVariableName;
    formattedColor = '#' + color.hex;
    sassVariableName = '$' + color.name.toLowerCase().trim().split(" ").join("-").replace("'", "");
    return sassVariableName + ": " + formattedColor + ";";
  };

  return SASSFormatter;

})(FormatterBase);

UIColorSwiftFormatter = (function(superClass) {
  extend(UIColorSwiftFormatter, superClass);

  function UIColorSwiftFormatter() {
    return UIColorSwiftFormatter.__super__.constructor.apply(this, arguments);
  }

  UIColorSwiftFormatter.prototype.id = function() {
    return "UICOLOR_SWIFT";
  };

  UIColorSwiftFormatter.prototype.name = function() {
    return "UIColor (Swift)";
  };

  UIColorSwiftFormatter.prototype.format = function() {
    return "colors.m";
  };

  UIColorSwiftFormatter.prototype.formatText = function(color, commented) {
    var alpha, blue, formattedColor, green, red;
    red = Math.round(color.red * 100) / 100;
    green = Math.round(color.green * 100) / 100;
    blue = Math.round(color.blue * 100) / 100;
    alpha = Math.round(color.alpha * 100) / 100;
    formattedColor = "UIColor(red:" + red + ", green:" + green + ", blue:" + blue + ", alpha:" + alpha + ")";
    if (commented) {
      return formattedColor + " // " + color.name;
    } else {
      return formattedColor;
    }
  };

  return UIColorSwiftFormatter;

})(FormatterBase);

UIColorObjCFormatter = (function(superClass) {
  extend(UIColorObjCFormatter, superClass);

  function UIColorObjCFormatter() {
    return UIColorObjCFormatter.__super__.constructor.apply(this, arguments);
  }

  UIColorObjCFormatter.prototype.id = function() {
    return "UICOLOR_OBJC";
  };

  UIColorObjCFormatter.prototype.name = function() {
    return "UIColor (Objective-C)";
  };

  UIColorObjCFormatter.prototype.format = function() {
    return "colors.m";
  };

  UIColorObjCFormatter.prototype.formatText = function(color, commented) {
    var alpha, blue, formattedColor, green, red;
    red = Math.round(color.red * 100) / 100;
    green = Math.round(color.green * 100) / 100;
    blue = Math.round(color.blue * 100) / 100;
    alpha = Math.round(color.alpha * 100) / 100;
    formattedColor = "[UIColor colorWithRed:" + red + " green:" + green + " blue:" + blue + " alpha:" + alpha + "];";
    if (commented) {
      return formattedColor + " // " + color.name;
    } else {
      return formattedColor;
    }
  };

  return UIColorObjCFormatter;

})(FormatterBase);

AndroidJavaFormatter = (function(superClass) {
  extend(AndroidJavaFormatter, superClass);

  function AndroidJavaFormatter() {
    return AndroidJavaFormatter.__super__.constructor.apply(this, arguments);
  }

  AndroidJavaFormatter.prototype.id = function() {
    return "ANDROID";
  };

  AndroidJavaFormatter.prototype.name = function() {
    return "Android ARGB (Java code)";
  };

  AndroidJavaFormatter.prototype.format = function() {
    return "colors.java";
  };

  AndroidJavaFormatter.prototype.formatText = function(color, commented) {
    var formattedColor;
    formattedColor = "Color.argb(" + (Math.round(color.alpha * 255)) + "," + (Math.round(color.red * 255)) + "," + (Math.round(color.green * 255)) + "," + (Math.round(color.blue * 255)) + ");";
    if (commented) {
      return formattedColor + " // " + color.name;
    } else {
      return formattedColor;
    }
  };

  return AndroidJavaFormatter;

})(FormatterBase);

AndroidXMLFormatter = (function(superClass) {
  extend(AndroidXMLFormatter, superClass);

  function AndroidXMLFormatter() {
    return AndroidXMLFormatter.__super__.constructor.apply(this, arguments);
  }

  AndroidXMLFormatter.prototype.id = function() {
    return "ANDROID_XML";
  };

  AndroidXMLFormatter.prototype.name = function() {
    return "Android ARGB (XML)";
  };

  AndroidXMLFormatter.prototype.format = function() {
    return "colors.xml";
  };

  AndroidXMLFormatter.prototype.formatText = function(color, commented) {
    var formattedColor, xmlVariable;
    formattedColor = "" + helperHex(color.alpha * 255) + color.hex;
    xmlVariable = '<color name="' + color.name.toLowerCase().trim().split(" ").join("_") + '">#' + formattedColor + "</color>";
    return xmlVariable;
  };

  return AndroidXMLFormatter;

})(FormatterBase);

CLRFormatter = (function(superClass) {
  extend(CLRFormatter, superClass);

  function CLRFormatter() {
    return CLRFormatter.__super__.constructor.apply(this, arguments);
  }

  CLRFormatter.prototype.id = function() {
    return "CLR";
  };

  CLRFormatter.prototype.name = function() {
    return "CLR (Color Lists)";
  };

  CLRFormatter.prototype.format = function() {
    return "colors.clr";
  };

  CLRFormatter.prototype.supportClipboard = function() {
    return false;
  };

  CLRFormatter.prototype.exportAsFile = function(colorDictionaries, url) {
    var alpha, blue, color, colorDictionary, colorList, green, i, len, red;
    colorList = NSColorList.alloc().initWithName("colors");
    for (i = 0, len = colorDictionaries.length; i < len; i++) {
      colorDictionary = colorDictionaries[i];
      red = Math.round(colorDictionary.red * 100) / 100;
      green = Math.round(colorDictionary.green * 100) / 100;
      blue = Math.round(colorDictionary.blue * 100) / 100;
      alpha = Math.round(colorDictionary.alpha * 100) / 100;
      color = NSColor.colorWithSRGBRed_green_blue_alpha(red, green, blue, alpha);
      colorList.setColor_forKey(color, colorDictionary.name);
    }
    return colorList.writeToFile(url.path());
  };

  return CLRFormatter;

})(FormatterBase);

ColorSetFormatter = (function(superClass) {
  extend(ColorSetFormatter, superClass);

  function ColorSetFormatter() {
    return ColorSetFormatter.__super__.constructor.apply(this, arguments);
  }

  ColorSetFormatter.prototype.id = function() {
    return "COLORSET";
  };

  ColorSetFormatter.prototype.name = function() {
    return "Color set (Xcode named color)";
  };

  ColorSetFormatter.prototype.type = function() {
    return this.constructor.EXPORT_TYPE_FILES;
  };

  ColorSetFormatter.prototype.supportClipboard = function() {
    return false;
  };

  ColorSetFormatter.prototype.exportAsFile = function(colorDictionaries, url) {
    var colorDictionary, colorsetURL, fileName, fileString, i, len, manager, name, obj, path, results;
    manager = NSFileManager.defaultManager();
    results = [];
    for (i = 0, len = colorDictionaries.length; i < len; i++) {
      colorDictionary = colorDictionaries[i];
      obj = this.contentsJSON(colorDictionary);
      name = colorDictionary.name.toLowerCase().trim().split(" ").join("_");
      fileName = name + ".colorset";
      colorsetURL = url.URLByAppendingPathComponent(fileName);
      manager.createDirectoryAtPath_withIntermediateDirectories_attributes_error(colorsetURL.path(), true, null, null);
      path = colorsetURL.path();
      fileString = NSString.stringWithString(JSON.stringify(obj));
      results.push(fileString.writeToFile_atomically_encoding_error(path + "/Contents.json", true, NSUTF8StringEncoding, null));
    }
    return results;
  };

  ColorSetFormatter.prototype.contentsJSON = function(colorDictionary) {
    var c, obj;
    c = this.colorObject(colorDictionary);
    return obj = {
      info: {
        version: 1,
        author: "com.ment.sketch.prism"
      },
      colors: [c]
    };
  };

  ColorSetFormatter.prototype.colorObject = function(colorDictionary) {
    var color, obj;
    color = {
      "color-space": "display-p3",
      components: this.colorComponents(colorDictionary)
    };
    return obj = {
      idiom: "universal",
      color: color
    };
  };

  ColorSetFormatter.prototype.colorComponents = function(colorDictionary) {
    var obj;
    return obj = {
      red: parseFloat(colorDictionary.red).toFixed(3),
      green: parseFloat(colorDictionary.green).toFixed(3),
      blue: parseFloat(colorDictionary.blue).toFixed(3),
      alpha: parseFloat(colorDictionary.alpha).toFixed(3)
    };
  };

  return ColorSetFormatter;

})(FormatterBase);

SketchMeasureFormatter = (function(superClass) {
  extend(SketchMeasureFormatter, superClass);

  function SketchMeasureFormatter() {
    return SketchMeasureFormatter.__super__.constructor.apply(this, arguments);
  }

  SketchMeasureFormatter.prototype.id = function() {
    return "SKETCHMESURE_JSON";
  };

  SketchMeasureFormatter.prototype.name = function() {
    return "Sketch Measure (JSON)";
  };

  SketchMeasureFormatter.prototype.format = function() {
    return "colors.json";
  };

  SketchMeasureFormatter.prototype.supportClipboard = function() {
    return true;
  };

  SketchMeasureFormatter.prototype.exportAsString = function(colorDictionaries) {
    var colorDictionary, i, len, obj, root;
    root = [];
    for (i = 0, len = colorDictionaries.length; i < len; i++) {
      colorDictionary = colorDictionaries[i];
      log(colorDictionary);
      obj = {
        "name": "" + colorDictionary.name,
        "color": this.colorToDictionaryToJSON(colorDictionary)
      };
      root.push(obj);
    }
    return JSON.stringify(root, void 0, 4);
  };

  SketchMeasureFormatter.prototype.colorToDictionaryToJSON = function(colorDictionary) {
    var json;
    return json = {
      r: Math.round(colorDictionary.red * 255),
      g: Math.round(colorDictionary.green * 255),
      b: Math.round(colorDictionary.blue * 255),
      a: Math.round(colorDictionary.alpha * 100) / 100,
      "color-hex": ("\#" + colorDictionary.hex + " ") + ((Math.round(colorDictionary.alpha * 100)) + "%"),
      "argb-hex": "\#" + (helperHex(colorDictionary.alpha * 255) + colorDictionary.hex),
      "css-rgba": "rgba(" + (Math.round(colorDictionary.red * 255)) + "," + (Math.round(colorDictionary.green * 255)) + "," + (Math.round(colorDictionary.blue * 255)) + "," + (Math.round(colorDictionary.alpha * 100) / 100) + ")",
      "ui-color": "(r:" + ((Math.round(colorDictionary.red * 100) / 100).toFixed(2)) + " g:" + ((Math.round(colorDictionary.green * 100) / 100).toFixed(2)) + " b:" + ((Math.round(colorDictionary.blue * 100) / 100).toFixed(2)) + " a:" + ((Math.round(colorDictionary.alpha * 100) / 100).toFixed(2)) + ")"
    };
  };

  return SketchMeasureFormatter;

})(FormatterBase);
